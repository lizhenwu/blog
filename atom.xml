<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog | windmill_</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://lizhenwu.github.io/blog/"/>
  <updated>2018-04-21T09:02:48.946Z</updated>
  <id>https://lizhenwu.github.io/blog/</id>
  
  <author>
    <name>windmill_</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dialog下落放大动画几种实现</title>
    <link href="https://lizhenwu.github.io/blog/2018/04/21/dialog%E4%B8%8B%E8%90%BD%E6%94%BE%E5%A4%A7%E5%8A%A8%E7%94%BB%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://lizhenwu.github.io/blog/2018/04/21/dialog下落放大动画几种实现/</id>
    <published>2018-04-21T09:02:48.000Z</published>
    <updated>2018-04-21T09:02:48.946Z</updated>
    
    <content type="html"><![CDATA[<p>这是在腾讯现场面试时候被问到的一个问题，要实现的是一个<code>dialog</code>从顶部下落到页面正中之后放大的动画，当时回答了用<code>animation</code>和<code>transition</code>加<code>transitionend</code>事件两种方式。后来又想起了另一种用<code>transition</code>的方式，并且发现了一个以前不知道的<code>tip</code>，总结一下。</p><a id="more"></a><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>用<code>animation</code>的方式比较简单，让<code>dialog</code>以绝对定位的加<code>top</code>加<code>translate</code>隐藏到页面上方居中，要显示时给它添加一个样式类，关键在于<code>animation-fill-mode</code>属性要为<code>forwards</code>，这样才能满足要求，具体实现及效果如下</p><script async src="//jsfiddle.net/_windmill/70u8wqw3/7/embed/"></script><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>不用<code>animation</code>只用<code>transition</code>的实现方式由于动画是分两部分完成的，所以<code>scale</code>放大的过程需要有一个delay的时间，而<code>transition</code>和<code>transform</code>属性都是支持多值的，所以实现起来也是很容易的，不过还是存在一个问题: 为了实现居中，<code>transform</code>里有一个<code>translate</code>的调整，而<code>transform</code>即使可以多值，但在<code>transition</code>中是独立的，也就是说<code>transform</code>里设置的<code>translate</code>、<code>scale</code>是不能在时间上分割<code>delay</code>的，所以最终的实现效果是下落过程开始后经过<code>transition</code>里设置的第二个值的<code>delay</code>时间后，而<code>dialog</code>没落到正中位置时就开始放大，而不是第一种方式那样落到正中位置后以<code>dialog</code>中心为原点放大。如下所示</p><script async src="//jsfiddle.net/_windmill/rcsuLyrv/7/embed/"></script><p>如果是确定宽高的<code>dialog</code>的话，用<code>margin-top</code>和<code>margin-left</code>分别设为高宽的一半负值的方式实现居中就不会有上面的问题，效果如下</p><script async src="//jsfiddle.net/_windmill/anshwk1o/embed/"></script><h3 id="transition-transitionend事件"><a href="#transition-transitionend事件" class="headerlink" title="transition+transitionend事件"></a>transition+transitionend事件</h3><p>还有一种用<code>transition</code>结合<code>transitionend</code>事件的方式，首先和前面一样要进行动画时添加上包含<code>transition</code>的样式类，这个样式类只完成让它居中的过渡，并且监听<code>dialog</code>的<code>transitionend</code>事件，在事件处理函数中将元素的<code>transform</code>设置成居中并且放大(添加<code>scale</code>)，最终效果如下:</p><script async src="//jsfiddle.net/_windmill/drvevdLb/20/embed/"></script><h3 id="一些发现"><a href="#一些发现" class="headerlink" title="一些发现"></a>一些发现</h3><p>实际上最后一种方式根本就是吃力不讨好，因为有更多js参与，并且<code>transitionend</code>在最后放大时也会触发。不过在实现的过程中我发现在<code>dialog</code>落到页面正中的过渡完成时，<code>transitionend</code>事件是触发了两次的，猜测是因为有<code>top</code>属性和<code>transform</code>两种属性的过渡，所以触发了两次，在MDN上查到这个事件有<code>propertyName</code>的属性就是反映的过渡的属性名，测试发现确实是我猜测的那样，每一个属性的过渡都触发一次<code>transitionend</code>事件，而我平时几乎没有用过<code>transition</code>多值的实现，都是直接<code>all</code>的处理，所以并不知道这回事。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/transitionend" target="_blank" rel="external">transitionend事件类型-mdn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是在腾讯现场面试时候被问到的一个问题，要实现的是一个&lt;code&gt;dialog&lt;/code&gt;从顶部下落到页面正中之后放大的动画，当时回答了用&lt;code&gt;animation&lt;/code&gt;和&lt;code&gt;transition&lt;/code&gt;加&lt;code&gt;transitionend&lt;/code&gt;事件两种方式。后来又想起了另一种用&lt;code&gt;transition&lt;/code&gt;的方式，并且发现了一个以前不知道的&lt;code&gt;tip&lt;/code&gt;，总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://lizhenwu.github.io/blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>失败的面试总结</title>
    <link href="https://lizhenwu.github.io/blog/2018/04/14/%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://lizhenwu.github.io/blog/2018/04/14/失败的面试总结/</id>
    <published>2018-04-14T08:25:44.000Z</published>
    <updated>2018-04-14T08:25:44.415Z</updated>
    
    <content type="html"><![CDATA[<p>这一个月的时间，一共投了阿里，腾讯，网易，头条（还有另外两家是音讯全无的状态）几家公司，阿里面了两次，头条两次，腾讯内推面试一次，现场面试一次，把这么多失败经历总结一下。</p><a id="more"></a><h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><p>阿里是在3月14号下午投简历的走内推，并没有想到当天晚上7点左右就接到了一面的电话。面试问题如下：</p><ul><li>对前端的理解</li><li>js闭包</li><li>端到端的适配</li><li>移动端怎么响应式</li><li>css3新特性</li><li>es6知道哪些</li><li>node全局对象有哪些</li><li>process对象有什么方法</li><li>对stream(流)的理解</li><li>对框架的理解，和jq有什么区别</li><li>有没有做过数据可视化</li></ul><p>3月19号下午二面，这一次一开始问了关于项目的问题了</p><ul><li>聊天室多开怎么处理</li><li>按钮点击波浪的实现</li><li>对移动端的理解</li><li>移动端怎么模拟hover效果</li><li>对vue和react的理解</li><li>讲一下自己项目觉得做的好的地方</li></ul><p>二面答得很不好反而没记住多少，很惭愧</p><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="内推一面"><a href="#内推一面" class="headerlink" title="内推一面"></a>内推一面</h3><p>一上来就问算法问题，直接懵逼</p><ul><li>有价值200的购物券怎么选四样商品使这个优惠券价值利用最大化</li><li>20G大小的文件，每一行都是一个QQ号，1G内存的机器，从中统计出现次数最多的QQ号</li><li>js闭包以及应用场景</li><li>http缓存，相关http头，其值的含义</li><li>web安全，CSRF，XSS防御</li><li>跨域</li><li>前端性能优化</li><li>快排的流程</li><li>http2新特性</li><li>自己项目遇到的问题以及怎么解决</li><li>学没学过操作系统…</li></ul><h3 id="现场一面"><a href="#现场一面" class="headerlink" title="现场一面"></a>现场一面</h3><ul><li>单页应用怎么SEO</li><li>怎么反爬虫</li><li>css选择器优先级（id父元素内嵌套的子元素按照自身的类还是父元素的样式）</li><li>实现dialog下落到页面中之后放大的动画</li><li>jquery选择器的实现</li><li>github随机头像怎么实现</li><li>http2新特性</li><li>跨域</li><li>node稳定性</li></ul><h2 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>css三角形实现</li><li>模态框实现，加动画</li><li>写节流函数</li><li>写树的后序遍历(递归和非递归)</li><li>http表单数据格式</li><li>http缓存 </li><li>cookie,session登录</li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>写排序加去重（不用内置方法）</li><li>实现一个观察者模式</li><li>讲一个自己项目的结构</li><li>mongoDB和mySQL的区别，应用场景</li><li>webpack编译流程</li><li>虚拟dom是怎么diff的</li><li>node稳定性</li><li>http2新特性</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了阿里的面试太仓促了没来得及准备，其他的面试都至少有一天的时间做了些准备。阿里二面的时候问到了自己项目里的一些具体实现，包括css样式效果和业务逻辑，发现自己做过的东西也不一定记得住，还是需要回顾，并且在项目的<code>readme</code>里应该<strong>记录</strong>一些设计上的规划和有意思的实现方式，这样做项目的收获才能最大化。</p><p>然后是简历，感觉头条的二面认真准备一下的话还是有机会的(那几天清明假光出去玩了)，比如快排如果回顾一下是应该能写出来的，再比如TM的<strong>观察者</strong>就是发布/订阅这件事居然忘了，当时写了个观察者加数据劫持把面试官逗乐了，给人很业余的感觉。因为简历上写了对虚拟dom有了解被问到了diff，当时天真地以为说一下render的流程就可以结果被问了怎么diff。简历上提到项目使用webpack构建于是被问到了webpack的流程，也是措手不及。所以为了简历好看点，还是得深入学习框架，工具等等，否则不敢写上去。同样地，在腾讯现场面试的时候被问jq选择器的实现也是因为简历上写了<code>读过部分jq源码</code>这种<code>naive</code>的骚话。</p><p>项目还需要再完善，自己做的东西在面试官看来太水太玩票，就算过了一面也只有二面陪跑的机会。</p><p>最后还是考虑一下需要实现的小目标，毕竟这么多失败的面试说明问题还是在于技术实力太辣鸡，虽然不一定有时间全部做到。<del>他妈的还能毕业吗</del></p><ol><li>算法，刷leetcode，类似于排序的简单算法要能手写</li><li>学点移动端的知识，比如移动端特有的事件处理</li><li>看点讲http的书，尤其是缓存相关</li><li>注重性能优化，SEO相关，至少要能说得上来一些具体方案</li><li>virtual-dom和jq源码学习既然已经挖坑了就继续</li><li>能手写一些设计模式，还有防抖节流这种常用方法</li><li>注意web安全，内存等问题</li><li>借助写一个webpack插件的过程来学习webpack</li><li>写博客          <code>!important</code></li><li>完善项目，最好能做出一些有<del>噱头</del>的功能</li></ol><hr><p>上面那些面试问题不全，如果能回忆起来的话再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一个月的时间，一共投了阿里，腾讯，网易，头条（还有另外两家是音讯全无的状态）几家公司，阿里面了两次，头条两次，腾讯内推面试一次，现场面试一次，把这么多失败经历总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://lizhenwu.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式学习</title>
    <link href="https://lizhenwu.github.io/blog/2017/08/30/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lizhenwu.github.io/blog/2017/08/30/js设计模式学习/</id>
    <published>2017-08-30T11:10:04.000Z</published>
    <updated>2018-04-12T03:15:58.529Z</updated>
    
    <content type="html"><![CDATA[<p>本文的概念、代码以及引用部分均来自网络，对，没有原创。原文链接<a href="http://blog.jobbole.com/29454/" target="_blank" rel="external">在此</a>(除了事件委托部分)</p><p><a href="http://www.cnblogs.com/xxcanghai/p/5189353.html" target="_blank" rel="external">一道变量声明和函数声明提升以及优先级的面试题</a></p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><blockquote><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数<br>越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能</p></blockquote><p>由于存在事件冒泡，给父元素添加事件，子元素触发该事件相应操作（例如点击事件）的时候会冒泡到父元素上从而触发该事件，这就是事件委托</p><p>用<code>event.target</code>(ie上是<code>event.srcElement</code>)控制事件来源范围，解决由于事件委托在父元素造成事件范围扩大的问题</p><p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p><p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p><p>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在比如说<strong>focus，blur之类的，本身就没用冒泡的特性</strong>，自然就不能用事件委托了。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的定义是产生一个类的唯一实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> createMask = singleton(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>));</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>使用场景比如页面遮罩层弹出对话框</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例经常都拥有相同的接口. 这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况。 说的通俗点，就像公司茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。</p><p>所谓的构造函数也是一个简单工厂。只是批了一件new的衣服. 我们扒掉这件衣服看看里面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjectFactory</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;,</div><div class="line"></div><div class="line">        Constructor = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    obj.__proto__ = <span class="keyword">typeof</span> Constructor.prototype === <span class="string">'number'</span> ? <span class="built_in">Object</span>.prototype</div><div class="line"></div><div class="line">        : Constructor.prototype;  <span class="comment">// 等于number这种情况会有??? !(Object.prototype.toString.call(Constructor.prototype) ===                                  // '[object Object]') 较好吧</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = ObjectFactory(A, <span class="string">'svenzeng'</span>);</div><div class="line"></div><div class="line">alert(a.name);  <span class="comment">//svenzeng</span></div></pre></td></tr></table></figure></p><p>以上代码来自es5的new和构造器的相关说明， 可以看到，所谓的new， 本身只是一个对象的复制和改写过程， 而具体会生成什么是由调用ObjectFactory时传进去的参数所决定的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的概念、代码以及引用部分均来自网络，对，没有原创。原文链接&lt;a href=&quot;http://blog.jobbole.com/29454/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在此&lt;/a&gt;(除了事件委托部分)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://lizhenwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>收一张js运算符优先级示意图</title>
    <link href="https://lizhenwu.github.io/blog/2017/08/23/%E6%94%B6%E4%B8%80%E5%BC%A0js%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%A4%BA%E6%84%8F%E5%9B%BE/"/>
    <id>https://lizhenwu.github.io/blog/2017/08/23/收一张js运算符优先级示意图/</id>
    <published>2017-08-23T07:14:17.000Z</published>
    <updated>2018-03-12T07:16:59.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/03/12/5aa6286ece935.png" alt="我是图"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 没事了就看一眼吧，万一有用呢(</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/03/12/5aa6286ece935.png&quot; alt=&quot;我是图&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="js" scheme="https://lizhenwu.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js的几种继承方式</title>
    <link href="https://lizhenwu.github.io/blog/2017/08/10/js%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>https://lizhenwu.github.io/blog/2017/08/10/js的几种继承方式/</id>
    <published>2017-08-09T16:00:00.000Z</published>
    <updated>2018-03-10T13:17:57.977Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原型链…利用原型让一个引用类型继承另一个引用类型的属性和方法…让原型对象等于另一个类型的实例，那么这个原型对象就包含了指向另一个类型的原型对象的指针(内部指针<code>[[prototype]]</code>或者说是<code>__proto__</code>)，相应地，另一个原型中包含着一个指向另一个类型的构造函数的指针(constructor)。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，就是原型链的基本概念。</p></blockquote><h2 id="原型链方式"><a href="#原型链方式" class="headerlink" title="原型链方式"></a>原型链方式</h2><p>实现原型链<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">Super.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 继承Super</span></div><div class="line">Sub.prototype = <span class="keyword">new</span> Super(); <span class="comment">// Sub的原型上会有Super的实例属性和方法</span></div><div class="line">Sub.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</div></pre></td></tr></table></figure></p><p>所有函数的默认原型都是Object的实例，因此默认原型都会包含一个指向<code>Object.prototype</code>的内部指针</p><p>但是由于包含引用类型值的原型属性被所有实例共享，在通过原型实现继承时，作为原型的实例的属性变成了子类型的原型属性，即子类型的所有实例共享作为子类原型的超类实例的实例属性。所以实践中很少单独使用这种方式实现继承。</p><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><blockquote><p>在子类型构造函数的内部调用超类型的构造函数…通过使用<code>apply</code> 和<code>call</code>方法在新创建的对象上执行构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</div><div class="line">instance1.colors.push(<span class="string">'black'</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">// ["red", "blue", "green", "black"]</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</div><div class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// ["red", "blue", "green"]</span></div></pre></td></tr></table></figure><p>相对于原型链的方式，借用构造函数的优势是可以在子类的构造函数中向超类型构造函数传递参数</p><p>缺陷是方法都在构造函数中定义，不能做到函数复用，超类原型中定义的方法对子类也是不可见的</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>将原型链和借用构造函数技术组合在一起<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, name);  <span class="comment">// 第二次调用Super</span></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();  <span class="comment">// 第一次调用Super</span></div><div class="line">Sub.prototype.constructor = Sub;</div><div class="line">Sub.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用两次Super的结果是在Sub的对象上有两组name, colors属性, 实例和原型上</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><blockquote><p>借助原型可以基于已有对象创建新对象同时不必因此创建自定义类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Super = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">''</span>;</div><div class="line">    friens: [];</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sub = object(Super)  <span class="comment">// Object.create</span></div></pre></td></tr></table></figure><p>和原型链继承方式一样包含引用类型值的属性是被共享的</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><blockquote><p>与前一种类似的方式，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回这个对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = object(original);</div><div class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(hi);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Nicholas'</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"shelly"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi(); <span class="comment">// "hi"</span></div></pre></td></tr></table></figure><p>与借用构造函数方式一样不能做到函数复用</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Sub, Super</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype = object(Super.prototype);</div><div class="line">    prototype.constructor = Sub;</div><div class="line">    Sub.prototype = prototype;</div><div class="line">&#125;</div><div class="line">inherit(Sub, Super);</div></pre></td></tr></table></figure><blockquote><p>…不必为了指定子类型的原型而调用超类型的构造函数…需要的无非就是超类型的原型的一个副本…只调用了一次超类型的构造函数，避免了在子类型的原型上创建多余的属性</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原型链…利用原型让一个引用类型继承另一个引用类型的属性和方法…让原型对象等于另一个类型的实例，那么这个原型对象就包含了指向另一个类型的原型对象的指针(内部指针&lt;code&gt;[[prototype]]&lt;/code&gt;或者说是&lt;code&gt;__proto__
      
    
    </summary>
    
    
      <category term="js" scheme="https://lizhenwu.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>搭建完成及后续展望</title>
    <link href="https://lizhenwu.github.io/blog/2017/06/04/%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%88%90%E5%8F%8A%E5%90%8E%E7%BB%AD%E5%B1%95%E6%9C%9B/"/>
    <id>https://lizhenwu.github.io/blog/2017/06/04/搭建完成及后续展望/</id>
    <published>2017-06-04T03:01:10.000Z</published>
    <updated>2018-03-12T10:48:23.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="终于搭建好了博客"><a href="#终于搭建好了博客" class="headerlink" title="终于搭建好了博客"></a>终于搭建好了博客</h3><p>之前收藏的markdown语法一图流找不着了。。。。 </p><h3 id="关于后续"><a href="#关于后续" class="headerlink" title="关于后续"></a>关于后续</h3><ul><li>博客界面样式之类</li><li>暂时还不知道怎么转载</li><li>hexo new之后直接跳转编辑参考 <a href="https://liam0205.me/2015/05/01/open-editor-after-hexo-new-immediately/" target="_blank" rel="external">click me</a></li><li><a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="external">markdown语法</a></li><li>图片路径问题还需要更好的解决办法（暂时用的绝对路径）还不知道是什么问题</li><li>…</li></ul><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><p>目前来看自己还非常非常菜，这个博客的建设可能会暂时搁置以后有空再操作。应该会继续写一些东西（可能和技术无关，因为我没有技术）。  </p><hr><p>先这样吧，马上去吃饭了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;终于搭建好了博客&quot;&gt;&lt;a href=&quot;#终于搭建好了博客&quot; class=&quot;headerlink&quot; title=&quot;终于搭建好了博客&quot;&gt;&lt;/a&gt;终于搭建好了博客&lt;/h3&gt;&lt;p&gt;之前收藏的markdown语法一图流找不着了。。。。 &lt;/p&gt;
&lt;h3 id=&quot;关于后续&quot;&gt;
      
    
    </summary>
    
    
      <category term="test" scheme="https://lizhenwu.github.io/blog/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lizhenwu.github.io/blog/2017/06/03/hello-world/"/>
    <id>https://lizhenwu.github.io/blog/2017/06/03/hello-world/</id>
    <published>2017-06-03T09:28:05.665Z</published>
    <updated>2017-06-03T09:28:05.674Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
