<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog | windmill_</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://lizhenwu.github.io/blog/"/>
  <updated>2018-05-25T02:30:09.117Z</updated>
  <id>https://lizhenwu.github.io/blog/</id>
  
  <author>
    <name>windmill_</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从vuex源码探索如何resetState</title>
    <link href="https://lizhenwu.github.io/blog/2018/05/25/%E4%BB%8Evuex%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2%E5%A6%82%E4%BD%95resetState/"/>
    <id>https://lizhenwu.github.io/blog/2018/05/25/从vuex源码探索如何resetState/</id>
    <published>2018-05-25T02:30:09.000Z</published>
    <updated>2018-05-25T02:30:09.117Z</updated>
    
    <content type="html"><![CDATA[<p>做聊天室项目时遇到一个注销登录时需要重置用户状态的问题，也就是需要把<code>vuex</code>状态管理的<code>state</code>对象重置为初始值，虽然最终有了一个解决方案，但还是决定再看看<code>vuex</code>源码。<br><a id="more"></a></p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>一开始写了一个很弱智的恢复初始状态的<code>mutation</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[SIGN_OUT](state) &#123;</div><div class="line">    state.user = localStorage.user = <span class="string">''</span>;</div><div class="line">    state.token.localStorage.token = <span class="string">''</span>;</div><div class="line">    state.loadingPosition = <span class="string">''</span>;</div><div class="line">    state.online = <span class="literal">false</span>;</div><div class="line">    state.socket =  <span class="literal">null</span>;</div><div class="line">    state.logedIn = <span class="literal">false</span>;</div><div class="line">    state.avatar = <span class="literal">null</span>;</div><div class="line">    state.rooms = [];</div><div class="line">    state.currentState = <span class="string">'online'</span>;</div><div class="line">    state.insideRoom = <span class="literal">false</span>;</div><div class="line">    state.currentRoomIdx = <span class="literal">undefined</span>;</div><div class="line">    state.onlineUsers = [];</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p><p>这种方式当然是非常不优雅的，所以决定重写一下，先定义一个初始<code>state</code>的简单对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// utils/data.js</span></div><div class="line"><span class="keyword">const</span> stateOrigin = &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后通过一个深复制方法初始化和重置<code>state</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// store/store.js</span></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</div><div class="line">    <span class="attr">state</span>: clone(stateOrigin),</div><div class="line">    <span class="attr">mutations</span>: [</div><div class="line">        ...</div><div class="line">        [RESET_STATE](state) &#123;</div><div class="line">            state = clone(stateOrigin);</div><div class="line">        &#125;,</div><div class="line">        ...</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>但是后来事实证明这样行不通，然后我<del>瞎蒙</del>着改成下面这种写法就成功了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mutations: [</div><div class="line">    ...</div><div class="line">    [RESET_STATE](state) &#123;</div><div class="line">        <span class="keyword">let</span> freshState = clone(stateOrigin);</div><div class="line">        <span class="comment">// 直接把freshState赋给state行不通</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> state) &#123;</div><div class="line">            state[i] = freshState[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">]</div></pre></td></tr></table></figure></p><h3 id="探索源码"><a href="#探索源码" class="headerlink" title="探索源码"></a>探索源码</h3><p>挂载<code>store</code>的过程<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.use(Vuex) -&gt; Vuex.install -&gt; Vue.mixin -&gt; beforeCreate -&gt; <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$options.store</div></pre></td></tr></table></figure></p><p>初始<code>state</code>的生成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> Vuex.Store())._modules -&gt; <span class="keyword">new</span> ModuleCollection().root -&gt; (<span class="keyword">new</span> Module(&#123;state&#125;)).state -&gt; &#123;options&#125;</div></pre></td></tr></table></figure><p><code>store</code>的原型有这样的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">get state () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._vm._data.$$state</div><div class="line">&#125;</div><div class="line">set state (v) &#123;</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      assert(<span class="literal">false</span>, <span class="string">`use store.replaceState() to explicit replace store state.`</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以，在<code>mutation</code>中操作的<code>state</code>实际上是<code>store</code>实例上的<code>_data.$$state</code>。如果在<code>mutation</code>里直接做<code>state = obj</code>这样的操作只是改变了引用，对<code>state</code>本身并无改变，这里是js函数参数传值传引用的问题。</p><p>到这里我的问题其实已经解决了。但是既然看了源码就不如多看点。</p><p>在<code>store.js</code>里发现<code>store</code>实例有一个<code>replaceState</code>方法，看起来它是官方提供的用于重置<code>state</code>的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">replaceState (state) &#123;</div><div class="line">    <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>._vm._data.$$state = state</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在创建<code>Store</code>实例时把传入的<code>mutations</code>的引用存储到一个数组里，以<code>{type: [mutations]}</code>的结构作为实例的<code>_mutations</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/store.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerMutation</span> (<span class="params">store, type, handler, local</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</div><div class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span> (<span class="params">payload</span>) </span>&#123;</div><div class="line">    handler.call(store, local.state, payload)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做聊天室项目时遇到一个注销登录时需要重置用户状态的问题，也就是需要把&lt;code&gt;vuex&lt;/code&gt;状态管理的&lt;code&gt;state&lt;/code&gt;对象重置为初始值，虽然最终有了一个解决方案，但还是决定再看看&lt;code&gt;vuex&lt;/code&gt;源码。&lt;br&gt;
    
    </summary>
    
    
      <category term="vuex" scheme="https://lizhenwu.github.io/blog/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>记录一个选择器的实现</title>
    <link href="https://lizhenwu.github.io/blog/2018/05/25/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://lizhenwu.github.io/blog/2018/05/25/记录一个选择器的实现/</id>
    <published>2018-05-25T02:28:53.000Z</published>
    <updated>2018-05-25T02:28:53.512Z</updated>
    
    <content type="html"><![CDATA[<p>看《javascript框架设计》这本书的时候发现作者写的一个选择器的实现，其中有一些<code>DOM API</code>的使用感觉很有意思。<br><a id="more"></a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先，这应该是一个比较hack并且兼容性强的选择器实现方式。<br>摘录自《javascript框架设计》p135的选择器源码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 兼容ie6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_$</span>(<span class="params">query</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> res = [];</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">document</span>.querySelector) &#123;</div><div class="line">        res = <span class="built_in">document</span>.querySelectorAll(query);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">var</span> firstStyleSheet = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>] || <span class="built_in">document</span>.createStyleSheet();</div><div class="line">        query = query.split(<span class="string">','</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; query.length; i++) &#123;</div><div class="line">            <span class="comment">// addRule是特定于IE的方法</span></div><div class="line">            firstStyleSheet.addRule(query[i], <span class="string">'Hack: ie'</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">document</span>.all.length; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">var</span> item = <span class="built_in">document</span>.all[i];</div><div class="line">            item.currentStyle.Hack &amp;&amp; res.push(item);</div><div class="line">        &#125;</div><div class="line">        firstStyleSheet.removeRule(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = res.length; i &lt; len; i++) &#123;</div><div class="line">        ret.push(res[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>实际测试的时候发现会出错</p><p><img src="https://i.loli.net/2018/05/18/5afe484028599.png" alt="图"></p><p>因为<code>addRule</code>是IE特有的方法，然后我在IE11上测试了一下是成功的，然后把<code>addRule</code>替换成mdn上看到的另一个方法<code>insertRule</code>，两者的参数规则不同，前者是传入三个参数: 第一个选择器字符串，第二个用冒号分割的css属性值字符串，第三个是一个数字表示插入规则的位置（可省略）,后者的参数是一个字符串类型的css规则（和css文件里写法一样），第二个是插入位置数字（可省略）。</p><p>这时候问题就来了，在同一个网站页面上使用<code>insertRule</code>插入css规则时，IE11不会报错但Chrome会报错</p><p>于是我在自己的网站上又用Chrome测试了一下发现是成功的，也就是说在chrome上操作的<code>CSSStyleSheet</code>必须是同源才能插入css规则。而在IE11上非同源的<code>CSSStyleSheet</code>也是可以插入的</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个方法中除了上面提过的的<code>CSSStyleSheet</code>接口和它的<code>insertRule</code>方法以外，还有<code>document.createStyleSheet</code>方法，<code>document.all</code>,<code>Element.currentStyle</code>。</p><p>其中<code>document.createStyleSheet</code>和<code>Element.currentStyle</code>都是IE特有的API，而<code>document.all</code>虽然也是IE的，但其他浏览器也有不同程度的支持，它返回页面中所有html标签的集合，但是在chrome中有这样的现象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">document</span>.all) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'no surpport for document.all'</span>); <span class="comment">// 控制台输出 no surpport for document.all</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但它确实是可以使用的，所以不能这样来检测是否支持，倒是可以用来检测当前浏览器是否IE。</p><p>然后，这个选择器方法的逻辑其实很简单，就是在<code>styleSheet</code>给要查找的元素添加一条css规则，然后遍历页面上所有元素看它是否有刚刚添加的那条css属性，有的话就是要选择的元素。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://developer.mozilla.org/en-US/docs/Web/API/StyleSheet" target="_blank" rel="external">MDN</a></p><hr><p>IE可真难用啊</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看《javascript框架设计》这本书的时候发现作者写的一个选择器的实现，其中有一些&lt;code&gt;DOM API&lt;/code&gt;的使用感觉很有意思。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://lizhenwu.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>面试相关问题</title>
    <link href="https://lizhenwu.github.io/blog/2018/05/07/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://lizhenwu.github.io/blog/2018/05/07/面试相关问题/</id>
    <published>2018-05-07T14:27:00.000Z</published>
    <updated>2018-05-08T02:56:58.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http2新特性"><a href="#http2新特性" class="headerlink" title="http2新特性"></a>http2新特性</h3><p>在HTTP的语义、HTTP方法、状态码、URI和首部字段等核心概念不变的情况下，HTTP/2实现了性能优化</p><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>HTTP1.x以换行符作为纯文本的分隔符，HTTP/2将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码</p><ul><li>帧：HTTP/2通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流</li><li>消息: 由一个或多个帧组合而成，例如请求和响应</li><li>连接: 与 HTTP/1 相同，都是指对应的 TCP 连接</li><li>流: 已建立的连接上的双向字节流</li></ul><p>在HTTP/2中，数据流以消息的形式发送，而消息由一个或多个帧组成，帧可以在数据流上乱序发送，然后再根据每个帧首部的流标识符重新组装。二进制分帧是HTTP/2的基石，其他优化都是在这一基础上来实现的</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP1.x中，如果想并发多个请求，必须使用多个TCP链接，且浏览器为了控制资源，还会对单个域名有6-8的个数限制</p><p>在 HTTP/2 中，有了二进制分帧之后，HTTP 2.0不再依赖TCP链接去实现多流并行, 同域名下所有通信都在单个连接上完成, 单个连接可以承载任意数量的双向数据流, 数据流以消息的形式发送, 而消息又由一个或多个帧组成, 多个帧可以乱序发送, 之后根据帧首部的流标识重新组装, 同个域名只需要占用一个TCP连接, 单个连接上可以并行交错的请求和响应，之间互不干扰</p><h4 id="流优先级"><a href="#流优先级" class="headerlink" title="流优先级"></a>流优先级</h4><p>在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧</p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>服务器除了响应客户端的请求外，还可以向客户端额外推送资源。服务器推送的资源有自己独立的URL， 可以被浏览器缓存，实现多页面共享。资源推送遵守同源策略，不能推送第三方资源，客户端可以拒绝推送过来的资源</p><h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>在客户端和服务端使用’首部表’跟踪和存储之前发送的键值对，不再在每次请求和响应时发送相同的头部数据</p><h4 id="应用层协商协议"><a href="#应用层协商协议" class="headerlink" title="应用层协商协议"></a>应用层协商协议</h4><p>升级协议时HTTP1.1 HTTP2.0并存，他们都使用80端口，通过协商选择通信的协议</p><p>客户端携带upgrade头部，服务端支持与否都不需要额外的往返</p><h3 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A%E6%B7%B1%E5%A4%8D%E5%88%B6" target="_blank" rel="external">mdn</a>上的对象深复制方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">objectToBeCloned</span>) </span>&#123;</div><div class="line">  <span class="comment">// Basis.</span></div><div class="line">  <span class="keyword">if</span> (!(objectToBeCloned <span class="keyword">instanceof</span> <span class="built_in">Object</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> objectToBeCloned;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> objectClone;</div><div class="line">  </div><div class="line">  <span class="comment">// Filter out special objects.</span></div><div class="line">  <span class="keyword">var</span> Constructor = objectToBeCloned.constructor;</div><div class="line">  <span class="keyword">switch</span> (Constructor) &#123;</div><div class="line">    <span class="comment">// Implement other special objects here.</span></div><div class="line">    <span class="keyword">case</span> <span class="built_in">RegExp</span>:</div><div class="line">      objectClone = <span class="keyword">new</span> Constructor(objectToBeCloned);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="built_in">Date</span>:</div><div class="line">      objectClone = <span class="keyword">new</span> Constructor(objectToBeCloned.getTime());</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      objectClone = <span class="keyword">new</span> Constructor();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// Clone each property.</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> objectToBeCloned) &#123;</div><div class="line">    objectClone[prop] = clone(objectToBeCloned[prop]);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> objectClone;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h3><p>优先级顺序:!important&gt;style&gt;id&gt;伪类&gt;属性选择器&gt;class&gt;tag&gt;声明先后顺序&gt;全局选择器。</p><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>[] == 0 成立是因为数组类型转换调用</p><p>a标签伪类lvha原则(love hate): link, visited, hover, active顺序排列, 否则效果会有覆盖的情况</p><h3 id="js作用域"><a href="#js作用域" class="headerlink" title="js作用域"></a>js作用域</h3><ul><li>es6之前无块级作用域</li><li>函数作用域</li><li>函数作用域链，作用域链在函数创建时就确定了(也就是词法作用域，由写在哪里决定)</li></ul><p>词法作用域(js)和动态作用域(非js，只是和this有点关系)</p><p>词法作用域就是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变</p><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</p><p>作用域查找从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止</p><p>函数在调用时会初始化一个活动对象（activation object），每个执行环境都有一个表示变量的对象称为变量对象，全局环境的变量对象一直存在，而函数局部环境的变量对象只在函数执行过程中存在，作用域链本质上是一个指向变量对象的指针列表(引用)，函数执行完之后销毁活动对象，函数中创建的函数的作用域链会包含外层函数的活动对象，所以即使外层函数执行完毕返回内部函数，由于它的活动对象被内部函数作用域链引用，所以不会销毁，形成闭包。闭包使用完之后赋值为null销毁其作用域链，也就释放了活动对象所占的内存(过度使用闭包导致内存占用过多)</p><p>在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”，内部的标识符“遮蔽”了外部的标识符</p><p>动态作用域并不关心函数和作用域是如何声明以及在任何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套</p><p>闭包是内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使是在其外部函数被返回之后</p><p>闭包使用场景</p><ul><li>闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作</li><li>管理私有变量和私有方法，将对变量的方法封装在安全的环境中</li><li>将代码封装成一个闭包形式，等待时机成熟时候再使用，比如实现柯里化</li><li>由于闭包内大的部分资源无法自动释放（GC），容易造成内存泄漏</li></ul><h3 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h3><p>let有块级作用域，没有提升，不能重复声明，不能在声明之前使用，<strong>let声明的全局变量不是全局对象的属性</strong>；var可以重复声明，作用域为函数作用域</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>promise的三个状态: pending, fulfilled, rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> </div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="垂直水平居中"><a href="#垂直水平居中" class="headerlink" title="垂直水平居中"></a>垂直水平居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">top</span>: 0; <span class="selector-tag">bottom</span>: 0; <span class="selector-tag">right</span>: 0; <span class="selector-tag">left</span>: 0;</div><div class="line"><span class="selector-tag">margin</span>: <span class="selector-tag">auto</span></div><div class="line"><span class="comment">/* 这种方法是通过为了满足上下左右都为0而拉伸margin，也就是要求元素有宽高才能居中 */</span></div></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>是ajax通信的一个主要限制，来源于浏览器同源策略，xhr对象只能访问与包含它的页面位于同一个域中的资源，预防某些恶意行为。</p><ol><li>CORS</li></ol><ul><li><p>CORS使用自定义的http头部让浏览器和服务器沟通从而决定请求或响应能否成功Origin和Access-Control-Allow-Origin，要包含cookie时需要Access-Control-Allow-Credentials头为true以及xhr.withCredentials = true;access-control-allow-origin为通配符时不能发送cookie</p></li><li><p>简单请求（get post head）不会触发预检请求, 包含自定义头部和put等方法都不是简单请求</p></li><li>“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</li><li>IE使用和xhr对象类似的xdr(XDomainRequest)实现安全可靠的跨域通信</li></ul><ol><li>图像ping</li></ol><p>一种与服务器进行简单单向的跨域通信方式，通过查询字符串方式发送请求数据，响应可以是任意内容，通常是像素图或204，浏览器得不到具体数据，只通过load和error事件知道响应接收时间。缺点是只能发送get请求，无法访问响应文本。常用于跟踪用户点击页面或动态广告曝光次数</p><ol><li>JSONP(json with padding,填充式json)</li></ol><p>在请求中指定回调函数：<a href="http://someurl.com/?callback=hadleresponse" target="_blank" rel="external">http://someurl.com/?callback=hadleresponse</a></p><p>优点是可以直接访问相应文本，浏览器与服务器双向通信，缺点是如果其他域不安全会在相应中夹带恶意代码，难以确定请求是否失败</p><ol><li><p>服务端代理跨域</p></li><li><p>postMessage跨域</p></li></ol><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递<br>用法postMessage(data, origin), data为基本类型值或可复制对象，一般用json.stringify转换</li></ul><ol><li>document.domain + iframe跨域</li></ol><p>仅限主域相同，子域不同的跨域应用场景，原理是两个页面都通过js强制设置document.domain为基础主域，其中一个通过iframe标签嵌入另一个页面，就实现了同域。</p><ol><li>window.name跨域</li></ol><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><p>HTTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略</p><p>Cache-Control 通用消息头被用于在http 请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的, 这意味着在请求设置的指令，在响应中不一定包含相同的指令。</p><p>ETag: 缓存的强校验器，ETag 响应头是一个对用户代理(User Agent, 下面简称UA)不透明（译者注：UA 无需理解，只需要按规定使用即可）的值。对于像浏览器这样的HTTP UA，不知道ETag代表什么，不能预测它的值是多少。如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。</p><p>Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它<strong>只能精确到一秒</strong>。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存，返回 200 ok表示返回正常的结果或者 304 Not Modified(不返回body)表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档的过期时间。</p><p>Vary HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。</p><p>Cache-Control:max-age&gt;0表示直接读取缓存, max-age=0时总是访问服务器并根据last-modified确定文件是否已更改。Cache-Control:no cache表示总是请求服务器最新文件，无304</p><p>如果还有一个 设置了 “max-age” 或者 “s-max-age” 指令的Cache-Control响应头，那么  Expires 头就会被忽略，expires表示响应资源失效时间</p><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>box-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。<br>border-box使元素宽度和高度设定应用到元素内容+内边距+边框，默认是content-box</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>HTTPS加密解密<a href="https://blog.csdn.net/shw372029857/article/details/52687906" target="_blank" rel="external">#</a></p><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p><a href="http://hpoenixf.com/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E6%96%B9%E6%A1%88.html" target="_blank" rel="external">rem布局方案</a></p><h3 id="token生成"><a href="#token生成" class="headerlink" title="token生成"></a>token生成</h3><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>这个方法原理其实也就跟setTimeout/setInterval差不多，通过递归调用同一方法来不断更新画面以达到动起来的效果，但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。</p><p>采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="external">HTTP状态码</a></h3><p>信息响应(临时响应)<br>100 continue<br>101 switching potocol Upgrade头，切换协议<br>102 processing 正在处理请求但无响应可用<br>成功响应<br>200 OK 请求成功<br>缓存相关 响应会带有头部 Cache-Control, Content-Location, Date, ETag, Expires，和 Vary<br>201 Created put请求成功后发送，表示已成功新建资源<br>202 Accepted 请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理<br>表示服务器端已经收到请求消息，但是尚未进行处理。但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。这个状态码被设计用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形<br>203 Non-Authoritative Information 表示请求已经成功被响应，但是获得的负载与源头服务器的状态码为 200 (OK)的响应相比，经过了拥有转换功能的 proxy （代理服务器）的修改<br>204 No Content 成功状态响应码表示目前请求成功，但客户端不需要更新其现有页面。204 响应默认是可以被缓存的。在响应中需要包含头信息 ETag<br>205 Reset Content 用来通知客户端重置文档视图，比如清空表单内容、重置 canvas 状态或者刷新用户界面<br>206 partial content 成功处理了部分GET请求<br>重定向<br>300 Multiple Choice 表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。由于没有如何进行选择的标准方法，这个状态码极少使用。<br>301 Moved Permanently 已经被移动到了由 Location 头部指定的url上，是固定的不会再改变。搜索引擎会根据该响应修正<br>302 Found 重定向状态码表明请求的资源被暂时的移动到了由Location 头部指定的 URL 上。浏览器会重定向到这个URL， 但是搜索引擎不会对该资源的链接进行更新<br>303 See Other 重定向状态码，通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET<br>304 Not Modified 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如GET 或HEAD 或在请求中附带了头部信息： If-None-Match 或If-Modified-Since<br>305 use Proxy 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应<br>307 状态码 307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化。当响应状态码为 302 的时候，一些旧有的用户代理会错误地将请求方法转换为 GET：使用非 GET 请求方法而返回 302 状态码<br>308 永久重定向, 和301的区别重定向过程中，请求方法和消息主体不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法<br>客户端响应<br>400 Bad Request</p><ol><li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</li><li>请求参数有误。<br>401 Unauthorized 认证错误<br>403 Forbidden 代表客户端错误，指的是服务器端有能力处理该请求，但是拒绝授权访问。类似于 401，但是进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）<br>404 not found 请求失败，请求所希望得到的资源未被在服务器上发现<br>405 method not allowed 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表<br>406 not acceptable 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体<br>407 Proxy Authentication Required 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。<br>408 request timeout 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改<br>409 Conflict 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<br>…<br>服务端响应<br>500 Internal Server Error 服务器内部错误<br>501 Not Implemented 此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码<br>502 bad gateway 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应<br>503 Service Unavailable 是一种HTTP协议的服务器端错误状态代码，它表示服务器尚未处于可以接受请求的状态<br>504 Gateway Timeout 服务器作为网关不能及时得到响应<br>505 HTTP Version Not Supported 不支持请求的协议版本</li></ol><h3 id="js严格模式"><a href="#js严格模式" class="headerlink" title="js严格模式"></a>js严格模式</h3><p>严格模式对正常的 JavaScript语义做了一些更改。<br>首先，严格模式消除了一些 JavaScript的静默错误，通过改变它们来抛出错误。<br>其次，严格的模式修复了 JavaScript引擎难以执行优化的错误：有时候，严格模式代码可以比非严格模式的相同的代码运行得更快。<br>第三，严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。<br><strong>不再支持 arguments.callee</strong></p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>jwt构成：header头部, payload载荷, signature签名</p><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><p>链接：<a href="http://hpoenixf.com/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89.html" target="_blank" rel="external">http://hpoenixf.com/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89.html</a></p><p>浏览器打开到页面渲染完成的过程</p><p>浏览器解析-&gt;查询缓存-&gt;dns查询-&gt;建立链接-&gt;服务器处理请求-&gt;服务器发送响应-&gt;客户端收到页面-&gt;解析HTML-&gt;构建渲染树-&gt;开始显示内容(白屏时间)-&gt;首屏内容加载完成(首屏时间)-&gt;用户可交互(DOMContentLoaded)-&gt;加载完成(load)</p><p>浏览器拿到html文档之后的渲染过程：1. 解析html，构建DOM树 2. 解析CSS，生成CSS规则树，3. 合并DOM树和CSS树 4. 布局render树，负责各元素尺寸、位置计算 5. 绘制render树，绘制页面像素信息 6. 浏览器将各层的信息发送给GPU，GPU将各层合成显示在屏幕上</p><p>性能优化可以分为页面加载时间跟页面运行效率两个方向</p><p>pageshow事件，e.persisted用来判断页面是否来自缓存</p><table><thead><tr><th>请求数量</th><th>合并脚本和样式表，CSS Sprites，按需加载资源，简化页面的设计</th></tr></thead><tbody><tr><td>请求带宽</td><td>开启GZip，压缩JavaScript和CSS ，移除重复脚本，图像优化</td></tr><tr><td>缓存利用</td><td>使用CDN，使用外部JavaScript和CSS，添加Expires头，配置ETag，减少DNS查找，使AjaX可缓存</td></tr><tr><td>页面结构</td><td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td></tr><tr><td>代码校验</td><td>避免重定向</td></tr></tbody></table><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>将数据给注入到代码里面变成可执行代码</p><p>防御XSS需要对用户输入过滤和转义，&amp; &lt; &gt; “ ‘ / 等符号转义成 &amp;amp &amp;lt &amp;gt &amp;quot &amp;#x27 &amp;#x2F</p><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 节流函数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>, result, timer, context, args</div><div class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    previous = <span class="built_in">Date</span>.now()</div><div class="line">    timer = <span class="literal">null</span></div><div class="line">    result = func.apply(context, args)</div><div class="line">    <span class="keyword">if</span>(!timer) args = context = <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</div><div class="line">    <span class="keyword">if</span>(!previous) previous = now</div><div class="line">    <span class="keyword">var</span> remaining = wait - (now - previous)</div><div class="line">    args = <span class="built_in">arguments</span></div><div class="line">    context = <span class="keyword">this</span></div><div class="line">    <span class="keyword">if</span>(remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</div><div class="line">      <span class="keyword">if</span>(timer) &#123;</div><div class="line">        clearTimeout(timer)</div><div class="line">        timer = <span class="literal">null</span></div><div class="line">      &#125;</div><div class="line">      previous = now</div><div class="line">      result = func.apply(<span class="keyword">this</span>, args)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!timer) &#123;</div><div class="line">      timer = setTimeout(later, remaining)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> throttled</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// by myself</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> timer, args, previous, ctx;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">later</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        previous = <span class="built_in">Date</span>.now();</div><div class="line">        timer = <span class="literal">null</span>;</div><div class="line">        func.apply(ctx, args);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</div><div class="line">        <span class="keyword">if</span>(!previous) previous = now;</div><div class="line">        <span class="keyword">let</span> remain = wait - (now - previous);</div><div class="line">        ctx = <span class="keyword">this</span>;</div><div class="line">        args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(remain &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(timer) &#123;</div><div class="line">                clearTimeout(timer);</div><div class="line">                timer = <span class="literal">null</span>;</div><div class="line">            &#125;</div><div class="line">            previous = now;</div><div class="line">            func.apply(ctx, args);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!timer)&#123;</div><div class="line">            timer = setTimeout(later, remain);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> throttled;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result, context, args, timer, first = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    timer = <span class="literal">null</span>;</div><div class="line">    result = func.apply(context, args);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    args = <span class="built_in">arguments</span>;</div><div class="line">    context = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span>(timer) clearTimeout(timer);</div><div class="line">    <span class="keyword">if</span>(immediate) &#123;</div><div class="line">      <span class="keyword">var</span> callnow = !timer;</div><div class="line"></div><div class="line">      timer = setTimeout(later, wait);</div><div class="line">      <span class="keyword">if</span>(callnow) &#123;</div><div class="line">        <span class="comment">// 第一次触发时直接执行</span></div><div class="line">        clearTimeout(timer);</div><div class="line">        result = func.apply(<span class="keyword">this</span>, args);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      timer = setTimeout(later, wait);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> debounced;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。替换元素是其内容不受CSS视觉格式化模型控制的元素，例如img标签，嵌入的文档（iframe之类）或者applet</p><h3 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h3><p>sessionStorage<br>​ 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。<br>localStorage<br>​同样的功能，但是在浏览器关闭，然后重新打开后，除非数据被清除，否则仍然存在。</p><h3 id="头条面试"><a href="#头条面试" class="headerlink" title="头条面试"></a>头条面试</h3><p>(一)</p><p>css三角形，模态框， 节流函数，树的后序遍历，http表单数据格式，http缓存， cookie,session登录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 后序遍历</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">node, cb</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">visit</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</div><div class="line">        visit(node.left);</div><div class="line">        visit(node.right);</div><div class="line">        cb(node);</div><div class="line">    &#125;</div><div class="line">    visit(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>(二)</p><p>排序算法+去重，观察者模式（发布/订阅），http2，mongoDB和mySQL对比加应用场景，介绍一个项目的结构，node服务器怎么保证稳定性，webpack编译过程以及插件怎么写，虚拟dom怎么做diff</p><h3 id="mongoDB对比mySQL"><a href="#mongoDB对比mySQL" class="headerlink" title="mongoDB对比mySQL"></a>mongoDB对比mySQL</h3><p><a href="https://www.cnblogs.com/imhurley/p/6060229.html" target="_blank" rel="external">参考链接</a></p><p>灵活的文档模型<br>高写入负载，高可用性，大数据量或未来会变得很大，基于位置的数据查询等等</p><h2 id="react虚拟DOM的diff算法"><a href="#react虚拟DOM的diff算法" class="headerlink" title="react虚拟DOM的diff算法"></a>react虚拟DOM的diff算法</h2><p>首先虚拟dom的流程: object -&gt; render生成VNode -&gt; createElement生成DOM节点 -&gt; 状态变化 -&gt; 生成新的VNode -&gt; diff新旧VNode生成patch对象 -&gt; patch遍历补丁更新DOM节点</p><p><a href="http://www.infoq.com/cn/articles/react-dom-diff/#" target="_blank" rel="external">参考链接1</a><br><a href="https://zhuanlan.zhihu.com/p/27437595" target="_blank" rel="external">参考链接2</a></p><ol><li>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；</li><li>对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// virtual-dom项目的diff</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> patch = &#123; <span class="attr">a</span>: a &#125;</div><div class="line">  walk(a, b, patch, <span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span> patch</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//patch的数据结构</span></div><div class="line">patch = &#123;</div><div class="line">  <span class="number">0</span>: &#123;VPatch&#125;,  <span class="comment">// key是旧的VNode的子节点索引, value是对应的Patch或Array&lt;VPatch&gt;</span></div><div class="line">  <span class="number">1</span>: &#123;VPatch&#125;,</div><div class="line">  ...</div><div class="line">  a: VNode</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">a, b, patch, index</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(a === b) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> apply = patch[index];</div><div class="line">  <span class="comment">// 标记是否清除旧节点的所有属性和状态</span></div><div class="line">  <span class="keyword">var</span> applyClear = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">if</span>(isThunk(a) || isThunk(b)) &#123;</div><div class="line">    <span class="comment">// thunk处理（开发者参与的diff）</span></div><div class="line">    <span class="comment">// ....</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(b === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="comment">// 新节点为null的处理</span></div><div class="line">    <span class="comment">// unhook();</span></div><div class="line">    <span class="comment">// destroyWidgets();</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(isVNode(b)) &#123;</div><div class="line">  <span class="comment">// 对VNode处理</span></div><div class="line">    <span class="keyword">if</span>(isVNode(a)) &#123;</div><div class="line">      <span class="comment">// 新旧节点元素相同只更新了属性</span></div><div class="line">      <span class="keyword">if</span>(a.tagName === b.tagName &amp;&amp; a.namespace === b.namespace &amp;&amp; a.key === b.key) &#123;</div><div class="line">        <span class="comment">// diffProps</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 新旧节点标签不同，直接更新为新节点</span></div><div class="line">        apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.VNODE, a, b))</div><div class="line">        applyClear = <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 对比子孙元素，递归</span></div><div class="line">      <span class="comment">// diffChildren函数内实现递归walk</span></div><div class="line">      apply = diffChildren(a, b, patch, apply, index);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 旧节点不是VNode而新节点是VNode</span></div><div class="line">      apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.VNode, a, b));</div><div class="line">      applyClear = <span class="literal">true</span>; </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 新节点是VText</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(isVText(b)) &#123;</div><div class="line">    <span class="comment">// 旧节点不是VText</span></div><div class="line">    <span class="keyword">if</span>(!isVText(a)) &#123;</div><div class="line">      apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.VText, a, b));</div><div class="line">      applyClear = <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a.text !== b.text) &#123;</div><div class="line">      <span class="comment">// 同为VText，但内容不同，直接新节点更新旧节点</span></div><div class="line">      apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.VText, a, b))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 对Widget的处理</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 根据patch更新DOM节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchRecursive</span>(<span class="params">rootNode, patches, renderOptions</span>) </span>&#123;</div><div class="line">  <span class="comment">// 取出patch的索引</span></div><div class="line">  <span class="keyword">var</span> idxs = patchIndices(patches);</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(idxs.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> rootNode;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 建立节点索引和dom节点映射关系</span></div><div class="line">  <span class="keyword">var</span> index = domIndex(rootNode, patches.a, idxs);</div><div class="line">  <span class="keyword">var</span> ownerDocument = rootNode.ownerDocument;</div><div class="line">  <span class="keyword">if</span>(!renderOptions.document &amp;&amp; ownerDocument !== <span class="built_in">document</span>) &#123;</div><div class="line">    renderOptions.document = ownerDocument</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; idxs.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> nodeIndex = idxs[i]</div><div class="line">        rootNode = applyPatch(rootNode,</div><div class="line">            index[nodeIndex],</div><div class="line">            patches[nodeIndex],</div><div class="line">            renderOptions)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rootNode</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// patchRecursive中打补丁的applyPatch方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatch</span>(<span class="params">vpatch, domNode, renderOptions</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> type = vpatch.type</div><div class="line">    <span class="keyword">var</span> vNode = vpatch.vNode</div><div class="line">    <span class="keyword">var</span> patch = vpatch.patch</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">        <span class="keyword">case</span> VPatch.REMOVE:</div><div class="line">            <span class="keyword">return</span> removeNode(domNode, vNode)</div><div class="line">        <span class="keyword">case</span> VPatch.INSERT:</div><div class="line">            <span class="keyword">return</span> insertNode(domNode, patch, renderOptions)</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>两种快排<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个非交换</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="comment">// function swap(arr, low, high) &#123;</span></div><div class="line">  <span class="comment">//   var m = arr[low];</span></div><div class="line">  <span class="comment">//   arr[low] = arr[high];</span></div><div class="line">  <span class="comment">//   arr[high] = m;</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</div><div class="line">    <span class="keyword">let</span> left = [], right = [];</div><div class="line">    <span class="keyword">let</span> base = arr[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span>(arr[i] &gt; base) &#123;</div><div class="line">        right.push(i);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        left.push(i);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    left = sort(left);</div><div class="line">    right = sort(right);</div><div class="line">    <span class="keyword">return</span> left.concat(base, right);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sort(arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="webpack插件开发"><a href="#webpack插件开发" class="headerlink" title="webpack插件开发"></a>webpack插件开发</h3><p><a href="http://www.css88.com/doc/webpack/development/how-to-write-a-plugin/" target="_blank" rel="external">参考链接</a></p><p>webpack编译流程,原理</p><p>一切皆模块，按需加载<br>“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载</p><p>webpack整体是一个插件架构，所有的功能都以插件的方式集成在构建流程中，通过发布订阅事件来触发各个插件执行</p><p>Compiler类的run方法 -&gt; Compilation</p><h3 id="抽象语法树-Abstract-Syntax-Tree"><a href="#抽象语法树-Abstract-Syntax-Tree" class="headerlink" title="抽象语法树(Abstract Syntax Tree)"></a>抽象语法树(Abstract Syntax Tree)</h3><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>AJAX不等于XMLHttpRequest<br>（异步JavaScript和XML）Asynchronous JavaScript + XML, 其本身不是一种新技术，而是一个在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML or XHTML, Cascading Style Sheets, JavaScript, The Document Object Model, XML, XSLT, 以及最重要的 XMLHttpRequest object。当使用结合了这些技术的AJAX模型以后， 网页程序能够快速地将渐步更新呈现在用户界面上，不需要重载（刷新）整个页面。这使得程序能够更快地回应用户的操作。<br>是一个为客户端提供的在客户端和服务器之间传输数据功能的API，并且不会使整个页面更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myAjax = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> xhrRequest = <span class="built_in">window</span>.XMLHttpRequest || <span class="built_in">window</span>.ActiveXObject</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">options, cb</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> method = options.method,</div><div class="line">        url = options.method,</div><div class="line">        data = options.data || <span class="literal">null</span>,</div><div class="line">        isAsync = options.isAsync;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> xhrRequest(<span class="string">'Microsoft.XMLHTTP'</span>);</div><div class="line">    <span class="keyword">if</span>(isAsync || isAsync === <span class="literal">undefined</span>) &#123;</div><div class="line">      xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</div><div class="line">          cb(xhr.responseText);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(method.toLowerCase() == <span class="string">'post'</span>) &#123;</div><div class="line">        xhr.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>)</div><div class="line">        data = dataTransfer(data)</div><div class="line">    &#125;</div><div class="line">    xhr.open(method, url, isAsync);</div><div class="line">    xhr.send(data);</div><div class="line">    <span class="keyword">if</span>(isAsync === <span class="literal">false</span>) &#123;</div><div class="line">      cb(xhr.responseText);</div><div class="line">    &#125;    </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"></div><div class="line">### Promise</div><div class="line"></div><div class="line">Promise实现</div><div class="line">`<span class="string">``</span>js</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> me = <span class="keyword">this</span>,</div><div class="line">        value = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.state = <span class="string">'pending'</span></div><div class="line">    <span class="keyword">this</span>.cbs = []</div><div class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> ret = isFunction(cb) &amp;&amp; cb(value) || value</div><div class="line">                <span class="keyword">if</span>(ret &amp;&amp; <span class="keyword">typeof</span> ret[<span class="string">'then'</span>] == <span class="string">'function'</span>) &#123;</div><div class="line">                    ret.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">                        resolve(value)</div><div class="line">                    &#125;)</div><div class="line">                &#125;</div><div class="line">                resolve(value)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(me.state === <span class="string">'pending'</span>) &#123;</div><div class="line">                me.cbs.push(handle)</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (me.state === <span class="string">'fufilled'</span>)&#123;</div><div class="line">                handle(value)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            me.state = <span class="string">'fufilled'</span></div><div class="line">            me.cbs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">                value = cb(value)</div><div class="line">            &#125;)</div><div class="line">        &#125;, <span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">    fn(resolve)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结构</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</div><div class="line">  <span class="keyword">this</span>.cbs = [];</div><div class="line">  <span class="keyword">let</span> me = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line"></div><div class="line">  &#125;;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        me.state = <span class="string">'fufilled'</span>;</div><div class="line">        me.cbs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">        value = func(value)</div><div class="line">      &#125;)</div><div class="line">    &#125;, <span class="number">0</span>)</div><div class="line">  &#125;</div><div class="line">  fn(resolve);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Promise.all实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAll</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)  =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> res = [];</div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    arr[i].then(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</div><div class="line">    res[i] = r;</div><div class="line">    count++;</div><div class="line">    <span class="keyword">if</span>(count===arr.length) &#123;</div><div class="line">        resolve(res);</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="腾讯现场一面"><a href="#腾讯现场一面" class="headerlink" title="腾讯现场一面"></a>腾讯现场一面</h3><p>单页应用怎么SEO，反爬虫，css选择器优先级（id父元素内嵌套的子元素按照自身的类还是父元素的样式），实现dialog下落之后放大的动画，jquery选择器的实现，github随机头像怎么设计，http2新特性，node稳定性（和头条二面一样的问题）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;http2新特性&quot;&gt;&lt;a href=&quot;#http2新特性&quot; class=&quot;headerlink&quot; title=&quot;http2新特性&quot;&gt;&lt;/a&gt;http2新特性&lt;/h3&gt;&lt;p&gt;在HTTP的语义、HTTP方法、状态码、URI和首部字段等核心概念不变的情况下，HTTP/2
      
    
    </summary>
    
    
      <category term="面试" scheme="https://lizhenwu.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>正则的test和exec方法</title>
    <link href="https://lizhenwu.github.io/blog/2018/05/06/%E6%AD%A3%E5%88%99%E7%9A%84test%E5%92%8Cexec%E6%96%B9%E6%B3%95/"/>
    <id>https://lizhenwu.github.io/blog/2018/05/06/正则的test和exec方法/</id>
    <published>2018-05-06T10:43:52.000Z</published>
    <updated>2018-05-06T10:43:52.810Z</updated>
    
    <content type="html"><![CDATA[<p>在做自己的<a href="https://github.com/lizhenwu/C-137" target="_blank" rel="external">聊天室项目时</a>的注册逻辑时碰到一个奇怪的bug，就是同一个用户名连续点击注册时得到的反馈信息不同，然后发现是正则验证写得有问题，主要是对test和exec的没理解到位。<br><a id="more"></a></p><h3 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">st=&gt;operation: 控制台未发现注册请求 </div><div class="line">st2=&gt;operation: 确定是前端验证问题</div><div class="line">st3=&gt;operation: 多次测试同一用户名</div><div class="line">st4=&gt;operation: 发现每隔几次会成功一次</div><div class="line">st5=&gt;operation: 查文档</div><div class="line"></div><div class="line">st-&gt;st2-&gt;st3-&gt;st4-&gt;st5</div></pre></td></tr></table></figure><h3 id="test方法"><a href="#test方法" class="headerlink" title="test方法"></a>test方法</h3><p>因为项目里用的<code>if(reg.test(str))</code>的方式验证输入是否符合要求，所以一开始并没觉得这里会有什么问题，经过多次测试发现每隔几次会出现一次符合预期的情况，大概记得exec方法有对同一个字符串多次执行返回不一样结果的特性，所以查了一下test方法，看到有这样的说明</p><p><img src="https://i.loli.net/2018/05/06/5aeec8b829665.png" alt="图"></p><p>这才算找到了问题根源。</p><h3 id="exec方法"><a href="#exec方法" class="headerlink" title="exec方法"></a>exec方法</h3><p>首先mdn上开头的解释如下</p><blockquote><p>exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。</p><p>如果你只是为了判断是否匹配（true或 false），可以使用 RegExp.test() 方法，或者 String.search() 方法。</p></blockquote><p>返回值</p><blockquote><p>如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。<br>如果匹配失败，exec() 方法返回 null</p></blockquote><p>正则表达式是个神奇的工具，如果是有<code>g</code>全局标记时，每一次调用<code>exec</code>方法会从正则表达式的<code>lastIndex</code>值为索引处开始搜索匹配，而匹配成功就更新这个属性为匹配结果的下一位索引，未匹配到则更新为0。这就是我项目里那个bug规律性出现的原因。</p><p>如果是用字面量正则表达式调用exec方法那么就不具备上述特性，相当于每次使用都新建了一个正则表达式。</p><h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h3><p>关于正则的$1等属性</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="external">RegExp.prototype.exec()</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做自己的&lt;a href=&quot;https://github.com/lizhenwu/C-137&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;聊天室项目时&lt;/a&gt;的注册逻辑时碰到一个奇怪的bug，就是同一个用户名连续点击注册时得到的反馈信息不同，然后发现是正则验证写得有问题，主要是对test和exec的没理解到位。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://lizhenwu.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>dialog下落放大动画几种实现</title>
    <link href="https://lizhenwu.github.io/blog/2018/04/21/dialog%E4%B8%8B%E8%90%BD%E6%94%BE%E5%A4%A7%E5%8A%A8%E7%94%BB%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://lizhenwu.github.io/blog/2018/04/21/dialog下落放大动画几种实现/</id>
    <published>2018-04-21T09:02:48.000Z</published>
    <updated>2018-04-21T09:02:48.946Z</updated>
    
    <content type="html"><![CDATA[<p>这是在腾讯现场面试时候被问到的一个问题，要实现的是一个<code>dialog</code>从顶部下落到页面正中之后放大的动画，当时回答了用<code>animation</code>和<code>transition</code>加<code>transitionend</code>事件两种方式。后来又想起了另一种用<code>transition</code>的方式，并且发现了一个以前不知道的<code>tip</code>，总结一下。</p><a id="more"></a><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>用<code>animation</code>的方式比较简单，让<code>dialog</code>以绝对定位的加<code>top</code>加<code>translate</code>隐藏到页面上方居中，要显示时给它添加一个样式类，关键在于<code>animation-fill-mode</code>属性要为<code>forwards</code>，这样才能满足要求，具体实现及效果如下</p><script async src="//jsfiddle.net/_windmill/70u8wqw3/7/embed/"></script><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>不用<code>animation</code>只用<code>transition</code>的实现方式由于动画是分两部分完成的，所以<code>scale</code>放大的过程需要有一个delay的时间，而<code>transition</code>和<code>transform</code>属性都是支持多值的，所以实现起来也是很容易的，不过还是存在一个问题: 为了实现居中，<code>transform</code>里有一个<code>translate</code>的调整，而<code>transform</code>即使可以多值，但在<code>transition</code>中是独立的，也就是说<code>transform</code>里设置的<code>translate</code>、<code>scale</code>是不能在时间上分割<code>delay</code>的，所以最终的实现效果是下落过程开始后经过<code>transition</code>里设置的第二个值的<code>delay</code>时间后，而<code>dialog</code>没落到正中位置时就开始放大，而不是第一种方式那样落到正中位置后以<code>dialog</code>中心为原点放大。如下所示</p><script async src="//jsfiddle.net/_windmill/rcsuLyrv/7/embed/"></script><p>如果是确定宽高的<code>dialog</code>的话，用<code>margin-top</code>和<code>margin-left</code>分别设为高宽的一半负值的方式实现居中就不会有上面的问题，效果如下</p><script async src="//jsfiddle.net/_windmill/anshwk1o/embed/"></script><h3 id="transition-transitionend事件"><a href="#transition-transitionend事件" class="headerlink" title="transition+transitionend事件"></a>transition+transitionend事件</h3><p>还有一种用<code>transition</code>结合<code>transitionend</code>事件的方式，首先和前面一样要进行动画时添加上包含<code>transition</code>的样式类，这个样式类只完成让它居中的过渡，并且监听<code>dialog</code>的<code>transitionend</code>事件，在事件处理函数中将元素的<code>transform</code>设置成居中并且放大(添加<code>scale</code>)，最终效果如下:</p><script async src="//jsfiddle.net/_windmill/drvevdLb/20/embed/"></script><h3 id="一些发现"><a href="#一些发现" class="headerlink" title="一些发现"></a>一些发现</h3><p>实际上最后一种方式根本就是吃力不讨好，因为有更多js参与，并且<code>transitionend</code>在最后放大时也会触发。不过在实现的过程中我发现在<code>dialog</code>落到页面正中的过渡完成时，<code>transitionend</code>事件是触发了两次的，猜测是因为有<code>top</code>属性和<code>transform</code>两种属性的过渡，所以触发了两次，在MDN上查到这个事件有<code>propertyName</code>的属性就是反映的过渡的属性名，测试发现确实是我猜测的那样，每一个属性的过渡都触发一次<code>transitionend</code>事件，而我平时几乎没有用过<code>transition</code>多值的实现，都是直接<code>all</code>的处理，所以并不知道这回事。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/transitionend" target="_blank" rel="external">transitionend事件类型-mdn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是在腾讯现场面试时候被问到的一个问题，要实现的是一个&lt;code&gt;dialog&lt;/code&gt;从顶部下落到页面正中之后放大的动画，当时回答了用&lt;code&gt;animation&lt;/code&gt;和&lt;code&gt;transition&lt;/code&gt;加&lt;code&gt;transitionend&lt;/code&gt;事件两种方式。后来又想起了另一种用&lt;code&gt;transition&lt;/code&gt;的方式，并且发现了一个以前不知道的&lt;code&gt;tip&lt;/code&gt;，总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://lizhenwu.github.io/blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>失败的面试总结</title>
    <link href="https://lizhenwu.github.io/blog/2018/04/14/%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://lizhenwu.github.io/blog/2018/04/14/失败的面试总结/</id>
    <published>2018-04-14T08:25:44.000Z</published>
    <updated>2018-04-14T08:25:44.415Z</updated>
    
    <content type="html"><![CDATA[<p>这一个月的时间，一共投了阿里，腾讯，网易，头条（还有另外两家是音讯全无的状态）几家公司，阿里面了两次，头条两次，腾讯内推面试一次，现场面试一次，把这么多失败经历总结一下。</p><a id="more"></a><h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><p>阿里是在3月14号下午投简历的走内推，并没有想到当天晚上7点左右就接到了一面的电话。面试问题如下：</p><ul><li>对前端的理解</li><li>js闭包</li><li>端到端的适配</li><li>移动端怎么响应式</li><li>css3新特性</li><li>es6知道哪些</li><li>node全局对象有哪些</li><li>process对象有什么方法</li><li>对stream(流)的理解</li><li>对框架的理解，和jq有什么区别</li><li>有没有做过数据可视化</li></ul><p>3月19号下午二面，这一次一开始问了关于项目的问题了</p><ul><li>聊天室多开怎么处理</li><li>按钮点击波浪的实现</li><li>对移动端的理解</li><li>移动端怎么模拟hover效果</li><li>对vue和react的理解</li><li>讲一下自己项目觉得做的好的地方</li></ul><p>二面答得很不好反而没记住多少，很惭愧</p><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="内推一面"><a href="#内推一面" class="headerlink" title="内推一面"></a>内推一面</h3><p>一上来就问算法问题，直接懵逼</p><ul><li>有价值200的购物券怎么选四样商品使这个优惠券价值利用最大化</li><li>20G大小的文件，每一行都是一个QQ号，1G内存的机器，从中统计出现次数最多的QQ号</li><li>js闭包以及应用场景</li><li>http缓存，相关http头，其值的含义</li><li>web安全，CSRF，XSS防御</li><li>跨域</li><li>前端性能优化</li><li>快排的流程</li><li>http2新特性</li><li>自己项目遇到的问题以及怎么解决</li><li>学没学过操作系统…</li></ul><h3 id="现场一面"><a href="#现场一面" class="headerlink" title="现场一面"></a>现场一面</h3><ul><li>单页应用怎么SEO</li><li>怎么反爬虫</li><li>css选择器优先级（id父元素内嵌套的子元素按照自身的类还是父元素的样式）</li><li>实现dialog下落到页面中之后放大的动画</li><li>jquery选择器的实现</li><li>github随机头像怎么实现</li><li>http2新特性</li><li>跨域</li><li>node稳定性</li></ul><h2 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>css三角形实现</li><li>模态框实现，加动画</li><li>写节流函数</li><li>写树的后序遍历(递归和非递归)</li><li>http表单数据格式</li><li>http缓存 </li><li>cookie,session登录</li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>写排序加去重（不用内置方法）</li><li>实现一个观察者模式</li><li>讲一个自己项目的结构</li><li>mongoDB和mySQL的区别，应用场景</li><li>webpack编译流程</li><li>虚拟dom是怎么diff的</li><li>node稳定性</li><li>http2新特性</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了阿里的面试太仓促了没来得及准备，其他的面试都至少有一天的时间做了些准备。阿里二面的时候问到了自己项目里的一些具体实现，包括css样式效果和业务逻辑，发现自己做过的东西也不一定记得住，还是需要回顾，并且在项目的<code>readme</code>里应该<strong>记录</strong>一些设计上的规划和有意思的实现方式，这样做项目的收获才能最大化。</p><p>然后是简历，感觉头条的二面认真准备一下的话还是有机会的(那几天清明假光出去玩了)，比如快排如果回顾一下是应该能写出来的，再比如TM的<strong>观察者</strong>就是发布/订阅这件事居然忘了，当时写了个观察者加数据劫持把面试官逗乐了，给人很业余的感觉。因为简历上写了对虚拟dom有了解被问到了diff，当时天真地以为说一下render的流程就可以结果被问了怎么diff。简历上提到项目使用webpack构建于是被问到了webpack的流程，也是措手不及。所以为了简历好看点，还是得深入学习框架，工具等等，否则不敢写上去。同样地，在腾讯现场面试的时候被问jq选择器的实现也是因为简历上写了<code>读过部分jq源码</code>这种<code>naive</code>的骚话。</p><p>项目还需要再完善，自己做的东西在面试官看来太水太玩票，就算过了一面也只有二面陪跑的机会。</p><p>最后还是考虑一下需要实现的小目标，毕竟这么多失败的面试说明问题还是在于技术实力太辣鸡，虽然不一定有时间全部做到。<del>他妈的还能毕业吗</del></p><ol><li>算法，刷leetcode，类似于排序的简单算法要能手写</li><li>学点移动端的知识，比如移动端特有的事件处理</li><li>看点讲http的书，尤其是缓存相关</li><li>注重性能优化，SEO相关，至少要能说得上来一些具体方案</li><li>virtual-dom和jq源码学习既然已经挖坑了就继续</li><li>能手写一些设计模式，还有防抖节流这种常用方法</li><li>注意web安全，内存等问题</li><li>借助写一个webpack插件的过程来学习webpack</li><li>写博客          <code>!important</code></li><li>完善项目，最好能做出一些有<del>噱头</del>的功能</li></ol><hr><p>上面那些面试问题不全，如果能回忆起来的话再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一个月的时间，一共投了阿里，腾讯，网易，头条（还有另外两家是音讯全无的状态）几家公司，阿里面了两次，头条两次，腾讯内推面试一次，现场面试一次，把这么多失败经历总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://lizhenwu.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式学习</title>
    <link href="https://lizhenwu.github.io/blog/2017/08/30/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lizhenwu.github.io/blog/2017/08/30/js设计模式学习/</id>
    <published>2017-08-30T11:10:04.000Z</published>
    <updated>2018-04-12T03:15:58.529Z</updated>
    
    <content type="html"><![CDATA[<p>本文的概念、代码以及引用部分均来自网络，对，没有原创。原文链接<a href="http://blog.jobbole.com/29454/" target="_blank" rel="external">在此</a>(除了事件委托部分)</p><p><a href="http://www.cnblogs.com/xxcanghai/p/5189353.html" target="_blank" rel="external">一道变量声明和函数声明提升以及优先级的面试题</a></p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><blockquote><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数<br>越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能</p></blockquote><p>由于存在事件冒泡，给父元素添加事件，子元素触发该事件相应操作（例如点击事件）的时候会冒泡到父元素上从而触发该事件，这就是事件委托</p><p>用<code>event.target</code>(ie上是<code>event.srcElement</code>)控制事件来源范围，解决由于事件委托在父元素造成事件范围扩大的问题</p><p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p><p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p><p>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在比如说<strong>focus，blur之类的，本身就没用冒泡的特性</strong>，自然就不能用事件委托了。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的定义是产生一个类的唯一实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> createMask = singleton(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>));</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>使用场景比如页面遮罩层弹出对话框</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例经常都拥有相同的接口. 这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况。 说的通俗点，就像公司茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。</p><p>所谓的构造函数也是一个简单工厂。只是批了一件new的衣服. 我们扒掉这件衣服看看里面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjectFactory</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;,</div><div class="line"></div><div class="line">        Constructor = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    obj.__proto__ = <span class="keyword">typeof</span> Constructor.prototype === <span class="string">'number'</span> ? <span class="built_in">Object</span>.prototype</div><div class="line"></div><div class="line">        : Constructor.prototype;  <span class="comment">// 等于number这种情况会有??? !(Object.prototype.toString.call(Constructor.prototype) ===                                  // '[object Object]') 较好吧</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = ObjectFactory(A, <span class="string">'svenzeng'</span>);</div><div class="line"></div><div class="line">alert(a.name);  <span class="comment">//svenzeng</span></div></pre></td></tr></table></figure></p><p>以上代码来自es5的new和构造器的相关说明， 可以看到，所谓的new， 本身只是一个对象的复制和改写过程， 而具体会生成什么是由调用ObjectFactory时传进去的参数所决定的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的概念、代码以及引用部分均来自网络，对，没有原创。原文链接&lt;a href=&quot;http://blog.jobbole.com/29454/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在此&lt;/a&gt;(除了事件委托部分)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://lizhenwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>收一张js运算符优先级示意图</title>
    <link href="https://lizhenwu.github.io/blog/2017/08/23/%E6%94%B6%E4%B8%80%E5%BC%A0js%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%A4%BA%E6%84%8F%E5%9B%BE/"/>
    <id>https://lizhenwu.github.io/blog/2017/08/23/收一张js运算符优先级示意图/</id>
    <published>2017-08-23T07:14:17.000Z</published>
    <updated>2018-03-12T07:16:59.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/03/12/5aa6286ece935.png" alt="我是图"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 没事了就看一眼吧，万一有用呢(</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/03/12/5aa6286ece935.png&quot; alt=&quot;我是图&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="js" scheme="https://lizhenwu.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js的几种继承方式</title>
    <link href="https://lizhenwu.github.io/blog/2017/08/10/js%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>https://lizhenwu.github.io/blog/2017/08/10/js的几种继承方式/</id>
    <published>2017-08-09T16:00:00.000Z</published>
    <updated>2018-03-10T13:17:57.977Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原型链…利用原型让一个引用类型继承另一个引用类型的属性和方法…让原型对象等于另一个类型的实例，那么这个原型对象就包含了指向另一个类型的原型对象的指针(内部指针<code>[[prototype]]</code>或者说是<code>__proto__</code>)，相应地，另一个原型中包含着一个指向另一个类型的构造函数的指针(constructor)。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，就是原型链的基本概念。</p></blockquote><h2 id="原型链方式"><a href="#原型链方式" class="headerlink" title="原型链方式"></a>原型链方式</h2><p>实现原型链<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">Super.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 继承Super</span></div><div class="line">Sub.prototype = <span class="keyword">new</span> Super(); <span class="comment">// Sub的原型上会有Super的实例属性和方法</span></div><div class="line">Sub.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</div></pre></td></tr></table></figure></p><p>所有函数的默认原型都是Object的实例，因此默认原型都会包含一个指向<code>Object.prototype</code>的内部指针</p><p>但是由于包含引用类型值的原型属性被所有实例共享，在通过原型实现继承时，作为原型的实例的属性变成了子类型的原型属性，即子类型的所有实例共享作为子类原型的超类实例的实例属性。所以实践中很少单独使用这种方式实现继承。</p><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><blockquote><p>在子类型构造函数的内部调用超类型的构造函数…通过使用<code>apply</code> 和<code>call</code>方法在新创建的对象上执行构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</div><div class="line">instance1.colors.push(<span class="string">'black'</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">// ["red", "blue", "green", "black"]</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</div><div class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// ["red", "blue", "green"]</span></div></pre></td></tr></table></figure><p>相对于原型链的方式，借用构造函数的优势是可以在子类的构造函数中向超类型构造函数传递参数</p><p>缺陷是方法都在构造函数中定义，不能做到函数复用，超类原型中定义的方法对子类也是不可见的</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>将原型链和借用构造函数技术组合在一起<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, name);  <span class="comment">// 第二次调用Super</span></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();  <span class="comment">// 第一次调用Super</span></div><div class="line">Sub.prototype.constructor = Sub;</div><div class="line">Sub.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用两次Super的结果是在Sub的对象上有两组name, colors属性, 实例和原型上</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><blockquote><p>借助原型可以基于已有对象创建新对象同时不必因此创建自定义类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Super = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">''</span>;</div><div class="line">    friens: [];</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sub = object(Super)  <span class="comment">// Object.create</span></div></pre></td></tr></table></figure><p>和原型链继承方式一样包含引用类型值的属性是被共享的</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><blockquote><p>与前一种类似的方式，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回这个对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = object(original);</div><div class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(hi);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Nicholas'</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"shelly"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi(); <span class="comment">// "hi"</span></div></pre></td></tr></table></figure><p>与借用构造函数方式一样不能做到函数复用</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Sub, Super</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype = object(Super.prototype);</div><div class="line">    prototype.constructor = Sub;</div><div class="line">    Sub.prototype = prototype;</div><div class="line">&#125;</div><div class="line">inherit(Sub, Super);</div></pre></td></tr></table></figure><blockquote><p>…不必为了指定子类型的原型而调用超类型的构造函数…需要的无非就是超类型的原型的一个副本…只调用了一次超类型的构造函数，避免了在子类型的原型上创建多余的属性</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原型链…利用原型让一个引用类型继承另一个引用类型的属性和方法…让原型对象等于另一个类型的实例，那么这个原型对象就包含了指向另一个类型的原型对象的指针(内部指针&lt;code&gt;[[prototype]]&lt;/code&gt;或者说是&lt;code&gt;__proto__
      
    
    </summary>
    
    
      <category term="js" scheme="https://lizhenwu.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>搭建完成及后续展望</title>
    <link href="https://lizhenwu.github.io/blog/2017/06/04/%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%88%90%E5%8F%8A%E5%90%8E%E7%BB%AD%E5%B1%95%E6%9C%9B/"/>
    <id>https://lizhenwu.github.io/blog/2017/06/04/搭建完成及后续展望/</id>
    <published>2017-06-04T03:01:10.000Z</published>
    <updated>2018-03-12T10:48:23.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="终于搭建好了博客"><a href="#终于搭建好了博客" class="headerlink" title="终于搭建好了博客"></a>终于搭建好了博客</h3><p>之前收藏的markdown语法一图流找不着了。。。。 </p><h3 id="关于后续"><a href="#关于后续" class="headerlink" title="关于后续"></a>关于后续</h3><ul><li>博客界面样式之类</li><li>暂时还不知道怎么转载</li><li>hexo new之后直接跳转编辑参考 <a href="https://liam0205.me/2015/05/01/open-editor-after-hexo-new-immediately/" target="_blank" rel="external">click me</a></li><li><a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="external">markdown语法</a></li><li>图片路径问题还需要更好的解决办法（暂时用的绝对路径）还不知道是什么问题</li><li>…</li></ul><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><p>目前来看自己还非常非常菜，这个博客的建设可能会暂时搁置以后有空再操作。应该会继续写一些东西（可能和技术无关，因为我没有技术）。  </p><hr><p>先这样吧，马上去吃饭了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;终于搭建好了博客&quot;&gt;&lt;a href=&quot;#终于搭建好了博客&quot; class=&quot;headerlink&quot; title=&quot;终于搭建好了博客&quot;&gt;&lt;/a&gt;终于搭建好了博客&lt;/h3&gt;&lt;p&gt;之前收藏的markdown语法一图流找不着了。。。。 &lt;/p&gt;
&lt;h3 id=&quot;关于后续&quot;&gt;
      
    
    </summary>
    
    
      <category term="test" scheme="https://lizhenwu.github.io/blog/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lizhenwu.github.io/blog/2017/06/03/hello-world/"/>
    <id>https://lizhenwu.github.io/blog/2017/06/03/hello-world/</id>
    <published>2017-06-03T09:28:05.665Z</published>
    <updated>2017-06-03T09:28:05.674Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
