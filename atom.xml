<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog | windmill_</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://lizhenwu.github.io/blog/"/>
  <updated>2018-04-12T03:15:58.529Z</updated>
  <id>https://lizhenwu.github.io/blog/</id>
  
  <author>
    <name>windmill_</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js设计模式学习</title>
    <link href="https://lizhenwu.github.io/blog/2017/08/30/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lizhenwu.github.io/blog/2017/08/30/js设计模式学习/</id>
    <published>2017-08-30T11:10:04.000Z</published>
    <updated>2018-04-12T03:15:58.529Z</updated>
    
    <content type="html"><![CDATA[<p>本文的概念、代码以及引用部分均来自网络，对，没有原创。原文链接<a href="http://blog.jobbole.com/29454/" target="_blank" rel="external">在此</a>(除了事件委托部分)</p><p><a href="http://www.cnblogs.com/xxcanghai/p/5189353.html" target="_blank" rel="external">一道变量声明和函数声明提升以及优先级的面试题</a></p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><blockquote><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数<br>越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能</p></blockquote><p>由于存在事件冒泡，给父元素添加事件，子元素触发该事件相应操作（例如点击事件）的时候会冒泡到父元素上从而触发该事件，这就是事件委托</p><p>用<code>event.target</code>(ie上是<code>event.srcElement</code>)控制事件来源范围，解决由于事件委托在父元素造成事件范围扩大的问题</p><p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p><p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p><p>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在比如说<strong>focus，blur之类的，本身就没用冒泡的特性</strong>，自然就不能用事件委托了。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的定义是产生一个类的唯一实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> createMask = singleton(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>));</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>使用场景比如页面遮罩层弹出对话框</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例经常都拥有相同的接口. 这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况。 说的通俗点，就像公司茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。</p><p>所谓的构造函数也是一个简单工厂。只是批了一件new的衣服. 我们扒掉这件衣服看看里面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjectFactory</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;,</div><div class="line"></div><div class="line">        Constructor = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    obj.__proto__ = <span class="keyword">typeof</span> Constructor.prototype === <span class="string">'number'</span> ? <span class="built_in">Object</span>.prototype</div><div class="line"></div><div class="line">        : Constructor.prototype;  <span class="comment">// 等于number这种情况会有??? !(Object.prototype.toString.call(Constructor.prototype) ===                                  // '[object Object]') 较好吧</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = ObjectFactory(A, <span class="string">'svenzeng'</span>);</div><div class="line"></div><div class="line">alert(a.name);  <span class="comment">//svenzeng</span></div></pre></td></tr></table></figure></p><p>以上代码来自es5的new和构造器的相关说明， 可以看到，所谓的new， 本身只是一个对象的复制和改写过程， 而具体会生成什么是由调用ObjectFactory时传进去的参数所决定的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的概念、代码以及引用部分均来自网络，对，没有原创。原文链接&lt;a href=&quot;http://blog.jobbole.com/29454/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在此&lt;/a&gt;(除了事件委托部分)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://lizhenwu.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>收一张js运算符优先级示意图</title>
    <link href="https://lizhenwu.github.io/blog/2017/08/23/%E6%94%B6%E4%B8%80%E5%BC%A0js%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%A4%BA%E6%84%8F%E5%9B%BE/"/>
    <id>https://lizhenwu.github.io/blog/2017/08/23/收一张js运算符优先级示意图/</id>
    <published>2017-08-23T07:14:17.000Z</published>
    <updated>2018-03-12T07:16:59.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/03/12/5aa6286ece935.png" alt="我是图"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 没事了就看一眼吧，万一有用呢(</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/03/12/5aa6286ece935.png&quot; alt=&quot;我是图&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="js" scheme="https://lizhenwu.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js的几种继承方式</title>
    <link href="https://lizhenwu.github.io/blog/2017/08/10/js%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>https://lizhenwu.github.io/blog/2017/08/10/js的几种继承方式/</id>
    <published>2017-08-09T16:00:00.000Z</published>
    <updated>2018-03-10T13:17:57.977Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原型链…利用原型让一个引用类型继承另一个引用类型的属性和方法…让原型对象等于另一个类型的实例，那么这个原型对象就包含了指向另一个类型的原型对象的指针(内部指针<code>[[prototype]]</code>或者说是<code>__proto__</code>)，相应地，另一个原型中包含着一个指向另一个类型的构造函数的指针(constructor)。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，就是原型链的基本概念。</p></blockquote><h2 id="原型链方式"><a href="#原型链方式" class="headerlink" title="原型链方式"></a>原型链方式</h2><p>实现原型链<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">Super.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 继承Super</span></div><div class="line">Sub.prototype = <span class="keyword">new</span> Super(); <span class="comment">// Sub的原型上会有Super的实例属性和方法</span></div><div class="line">Sub.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</div></pre></td></tr></table></figure></p><p>所有函数的默认原型都是Object的实例，因此默认原型都会包含一个指向<code>Object.prototype</code>的内部指针</p><p>但是由于包含引用类型值的原型属性被所有实例共享，在通过原型实现继承时，作为原型的实例的属性变成了子类型的原型属性，即子类型的所有实例共享作为子类原型的超类实例的实例属性。所以实践中很少单独使用这种方式实现继承。</p><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><blockquote><p>在子类型构造函数的内部调用超类型的构造函数…通过使用<code>apply</code> 和<code>call</code>方法在新创建的对象上执行构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</div><div class="line">instance1.colors.push(<span class="string">'black'</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">// ["red", "blue", "green", "black"]</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</div><div class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// ["red", "blue", "green"]</span></div></pre></td></tr></table></figure><p>相对于原型链的方式，借用构造函数的优势是可以在子类的构造函数中向超类型构造函数传递参数</p><p>缺陷是方法都在构造函数中定义，不能做到函数复用，超类原型中定义的方法对子类也是不可见的</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>将原型链和借用构造函数技术组合在一起<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, name);  <span class="comment">// 第二次调用Super</span></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();  <span class="comment">// 第一次调用Super</span></div><div class="line">Sub.prototype.constructor = Sub;</div><div class="line">Sub.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用两次Super的结果是在Sub的对象上有两组name, colors属性, 实例和原型上</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><blockquote><p>借助原型可以基于已有对象创建新对象同时不必因此创建自定义类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Super = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">''</span>;</div><div class="line">    friens: [];</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sub = object(Super)  <span class="comment">// Object.create</span></div></pre></td></tr></table></figure><p>和原型链继承方式一样包含引用类型值的属性是被共享的</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><blockquote><p>与前一种类似的方式，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回这个对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = object(original);</div><div class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(hi);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Nicholas'</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"shelly"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi(); <span class="comment">// "hi"</span></div></pre></td></tr></table></figure><p>与借用构造函数方式一样不能做到函数复用</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Sub, Super</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype = object(Super.prototype);</div><div class="line">    prototype.constructor = Sub;</div><div class="line">    Sub.prototype = prototype;</div><div class="line">&#125;</div><div class="line">inherit(Sub, Super);</div></pre></td></tr></table></figure><blockquote><p>…不必为了指定子类型的原型而调用超类型的构造函数…需要的无非就是超类型的原型的一个副本…只调用了一次超类型的构造函数，避免了在子类型的原型上创建多余的属性</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原型链…利用原型让一个引用类型继承另一个引用类型的属性和方法…让原型对象等于另一个类型的实例，那么这个原型对象就包含了指向另一个类型的原型对象的指针(内部指针&lt;code&gt;[[prototype]]&lt;/code&gt;或者说是&lt;code&gt;__proto__
      
    
    </summary>
    
    
      <category term="js" scheme="https://lizhenwu.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>搭建完成及后续展望</title>
    <link href="https://lizhenwu.github.io/blog/2017/06/04/%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%88%90%E5%8F%8A%E5%90%8E%E7%BB%AD%E5%B1%95%E6%9C%9B/"/>
    <id>https://lizhenwu.github.io/blog/2017/06/04/搭建完成及后续展望/</id>
    <published>2017-06-04T03:01:10.000Z</published>
    <updated>2018-03-12T10:48:23.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="终于搭建好了博客"><a href="#终于搭建好了博客" class="headerlink" title="终于搭建好了博客"></a>终于搭建好了博客</h3><p>之前收藏的markdown语法一图流找不着了。。。。 </p><h3 id="关于后续"><a href="#关于后续" class="headerlink" title="关于后续"></a>关于后续</h3><ul><li>博客界面样式之类</li><li>暂时还不知道怎么转载</li><li>hexo new之后直接跳转编辑参考 <a href="https://liam0205.me/2015/05/01/open-editor-after-hexo-new-immediately/" target="_blank" rel="external">click me</a></li><li><a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="external">markdown语法</a></li><li>图片路径问题还需要更好的解决办法（暂时用的绝对路径）还不知道是什么问题</li><li>…</li></ul><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><p>目前来看自己还非常非常菜，这个博客的建设可能会暂时搁置以后有空再操作。应该会继续写一些东西（可能和技术无关，因为我没有技术）。  </p><hr><p>先这样吧，马上去吃饭了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;终于搭建好了博客&quot;&gt;&lt;a href=&quot;#终于搭建好了博客&quot; class=&quot;headerlink&quot; title=&quot;终于搭建好了博客&quot;&gt;&lt;/a&gt;终于搭建好了博客&lt;/h3&gt;&lt;p&gt;之前收藏的markdown语法一图流找不着了。。。。 &lt;/p&gt;
&lt;h3 id=&quot;关于后续&quot;&gt;
      
    
    </summary>
    
    
      <category term="test" scheme="https://lizhenwu.github.io/blog/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lizhenwu.github.io/blog/2017/06/03/hello-world/"/>
    <id>https://lizhenwu.github.io/blog/2017/06/03/hello-world/</id>
    <published>2017-06-03T09:28:05.665Z</published>
    <updated>2017-06-03T09:28:05.674Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
